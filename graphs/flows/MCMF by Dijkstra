#include <iostream>
#include <map>
#include <vector>
#include <unordered_set>
#include <cstring>
#include <set>
#include <algorithm>
#include <queue>

using namespace std;
#define int long long
int s = 1e4+19, t = 1e4+20;
const int INF = 1e14;
vector<int> cost(1e4+200),sz(1e4+200);
struct edge{
    int v;
    int u;
    int c;
    int f;
    int cost;
    edge(int v, int u, int c, int f,int cost) : v(v), u(u), c(c), f(f), cost(cost) {}
    inline int gc() const{
        return c-f;
    }
};
int AAA = 0;
vector<vector<int>> g(1e4+200);
vector<edge> edges;
int n;
vector<int> dist(1e4+200, INF);
void FordBellman(){
    dist[s] = 0;
    for (int iteration = 0; iteration < 10; ++iteration) {
        for (int v = 0; v < 1e4+200; ++v) {
            if (dist[v] == INF) {
                continue;
            }
            for (auto e : g[v]) {
                auto& [ver,u,cap,f,cst] = edges[e];
                if (dist[u]>dist[v] + cst && cap-f>0){
                    dist[u] = dist[v]+cst;
                }
            }
        }
    }
}
int D(){
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
    vector<int> dist1(1e4+200,INF);
    vector<int> from(1e4+200,-1);
    vector<bool> used(1e4+200,false);
    q.emplace(0,s);
    dist1[s] = 0;
    while (!q.empty()){
        auto [w,v] = q.top();
        q.pop();
        if (used[v]){
            continue;
        }
        used[v] = true;
        for (int e : g[v]){
            auto& [ver,u,cap,f,cst] = edges[e];
            int w1 = dist1[v] + cst + dist[v] - dist[u];
            if (cap-f>0 && w1<0){
                throw runtime_error("LOL");
            }
            if (dist1[u]>w1 && cap-f>0){
                from[u] = e;
                dist1[u] = w1;
                q.emplace(w1,u);
            }
        }
    }
    if (from[t]==-1){
        return 0;
    }
    int x = t;
    int flow = 1e18;
    int c = 0;
    while (x!=s){
        c+=edges[from[x]].cost;
        flow = min(flow,edges[from[x]].gc());
        x = edges[from[x]].v;
    }
    x = t;
    while (x!=s){
        edges[from[x]].f+=flow;
        edges[from[x]^1].f-=flow;
        x = edges[from[x]].v;
    }
    AAA+=flow;
    for (int i = 0; i < 1e4+200; ++i) {
        dist[i]+=dist1[i];
    }
    return flow*c;
}
void solve(){
    string text;cin >> text;
    cin >> n;
    int cnt = text.size();
    vector<vector<int>> cnts('z'-'a'+1);
    for (int i = 0; i < cnt; ++i) {
        cnts[text[i]-'a'].push_back(i);
    }
    int ss = 1e4+21;
    for (int i = 0; i < n; ++i) {
        string str;int a;
        cin >> str >> a;
        for (char& c : str){
            for (int& l : cnts[c-'a']){
                g[cnt].emplace_back(edges.size());
                edges.emplace_back(cnt,l,1,0,0);
                g[l].emplace_back(edges.size());
                edges.emplace_back(l,cnt,0,0,0);
            }
            g[ss+i].emplace_back(edges.size());
            edges.emplace_back(ss+i,cnt,1,0,i+1);
            g[cnt].emplace_back(edges.size());
            edges.emplace_back(cnt,ss+i,0,0,-i-1);
            cnt++;
        }
        g[s].emplace_back(edges.size());
        edges.emplace_back(s,ss+i,a,0,0);
        g[ss+i].emplace_back(edges.size());
        edges.emplace_back(ss+i,s,0,0,0);
    }
    for (int i = 0; i < text.size(); ++i) {
        g[i].emplace_back(edges.size());
        edges.emplace_back(i,t,1,0,0);
        g[t].emplace_back(edges.size());
        edges.emplace_back(t,i,0,0,0);
    }
    int x = -1;
    int ans = 0;
    FordBellman();
    while (x = D()){
        ans+=x;
    }
    if (AAA!=text.size()){
        cout << -1 << endl;
        return;
    }
    cout << ans << endl;
}
signed main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    int qq = 1;
    //cin >> qq;
    while (qq--) {
        solve();
    }
    cout.flush();
}
